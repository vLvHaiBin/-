package com.example.mobilesafe.Utils;

import java.io.File;
import java.io.FileOutputStream;

import org.xmlpull.v1.XmlSerializer;

import android.content.ContentResolver;
import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.os.Environment;
import android.os.SystemClock;
import android.text.TextUtils;
import android.util.Xml;

public class SmsUtils {

	/**
	 * 备份短信的接口
	 * 
	 * @author Administrator
	 *
	 */
	public interface BackUpCallBackSms {

		public void befor(int count);

		public void onBackUpSms(int process);

	}

	public static boolean backUp(Context context, BackUpCallBackSms callback) {
		/**
		 * 目的 ： 备份短信：
		 * 
		 * 1 判断当前用户的手机上面是否有sd卡 2 权限 --- 使用内容观察者 3 写短信(写到sd卡)
		 * 
		 * 
		 */

		// 判断当前sd卡的状态
		if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
			// 如果能进来就说明用户有SD卡
			ContentResolver resolver = context.getContentResolver();
			// 获取短信的路径
			Uri uri = Uri.parse("content://sms/");
			// type = 1 接收短信
			// type = 2 发送短信
			// cursor 表示游标的意思
			Cursor cursor = resolver.query(uri, new String[] { "address", "date", "type", "body" }, null, null, null);
			// 获取当前一共有多少条短信
			int count = cursor.getCount();
			// 设置pd的最大值
			// pd.setMax(count);
			// progressBar1.setMax(count);

			callback.befor(count);

			// 进度条默认是0
			int process = 0;

			// 写文件
			try {
				// 把短信备份到sd卡 第二个参数表示名字
				File file = new File(Environment.getExternalStorageDirectory() + "/backupmessaggs");
				if (!file.exists()) {
					file.mkdir();
				}

				File file2 = new File(Environment.getExternalStorageDirectory() + "/backupmessaggs", "message.xml");
				FileOutputStream os = new FileOutputStream(file2);
				// 得到序列化器
				// 在android系统里面所有有关xml的解析都是pull解析
				XmlSerializer serializer = Xml.newSerializer();
				// 把短信序列化到sd卡然后设置编码格式
				serializer.setOutput(os, "utf-8");
				// standalone表示当前的xml是否是独立文件 ture表示文件独立。yes
				serializer.startDocument("utf-8", true);
				// 设置开始的节点 第一个参数是命名空间。第二个参数是节点的名字
				serializer.startTag(null, "smss");
				// 设置smss节点上面的属性值 第二个参数是名字。第三个参数是值
				serializer.attribute(null, "size", String.valueOf(count));
				// 游标往下面进行移动
				while (cursor.moveToNext()) {
					System.err.println("----------------------------");
					System.out.println("address = " + cursor.getString(0));
					System.out.println("date = " + cursor.getString(1));
					System.out.println("type = " + cursor.getString(2));
					System.out.println("body = " + cursor.getString(3));

					serializer.startTag(null, "sms");

					serializer.startTag(null, "address");
					// 设置文本的内容
					String address = cursor.getString(0);
					if(TextUtils.isEmpty(address)){//必须判断
						serializer.text("");
					}else {
						serializer.text(address);
					}
					serializer.endTag(null, "address");

					serializer.startTag(null, "date");
					
					String date = cursor.getString(1);
					if(TextUtils.isEmpty(address)){
						serializer.text("");
					}else {
						serializer.text(date);
					}
					

					serializer.endTag(null, "date");

					serializer.startTag(null, "type");

					String type = cursor.getString(2);
					if(TextUtils.isEmpty(address)){
						serializer.text("");
					}else {
						serializer.text(type);
					}
					
					serializer.endTag(null, "type");

					serializer.startTag(null, "body");

					// 读取短信的内容
					/**
					 * 加密：第一个参数表示加密种子(密钥) 第二个参数表示加密的内容
					 */
					String body = cursor.getString(3);
					if(TextUtils.isEmpty(address)){
						serializer.text("");
					}else {
						serializer.text(body);
					}
					

					serializer.endTag(null, "body");

					serializer.endTag(null, "sms");
					// 序列化完一条短信之后就需要++
					process++;

					// pd.setProgress(process);
					//
					// progressBar1.setProgress(process);

					callback.onBackUpSms(process);

					SystemClock.sleep(200);

				}
				if (cursor.moveToLast()) {
					cursor.close();
					serializer.endDocument();
					os.flush();
					os.close();
				}

				serializer.endTag(null, "smss");

				return true;

			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}

		return false;
	}

}
